
<a name="hcompmgrpost"
<article .blogpost
    <header
        <h3 
            Hcompmgr
        <pubdate date="2011-04-15" pubdate
            April 15, 2011
    <div .blogentry
        <p>For my senior capstone at Simpson College, I chose to attempt to write a compositor for X11 in haskell, with the eventual intent of integrating it with XMonad.  While standalone compositors like xcompmgr and cairo-compmgr exist and can be used with XMonad, they all are very limited in the enhancements they can provide due to lack of integration between the compositor and window manager, and their use of XRender as a rendering backend means that transformations like scaling and distrortion are not well-accelererated, and proper VSync for tear-free rendering is impossible.  Thus why I chose to implement it in haskell and OpenGL, since being in haskell would make it possible to integrate with XMonad, which is also written in haskell, and OpenGL offers the most-complete graphics acceleration for Linux at this time.  There are also no existing compositors designed to work specifically with a tiling window manager as opposed to more-traditional stacking window managers, so I felt that exploring the possibilities compositing would bring to a tiling environment might be interesting. Unfortunately my project, dubbed Hcompmgr, has failed to meet my goals in many ways.

        <p>Why did Hcompmgr fail? There are two main reasons. Firstly, the scope of this project was perhaps a bit larger than appropriate for a semester’s worth of work.  Before starting hcompmgr, I had only minimal experience with Haskell, and no experience programming with OpenGL, libx11, or any of the several X11 extensions needed to write a compositor - most of which did not already have bindings for haskell, or had only incomplete or bitrotted bindings.  Accordingly, most of my time was expended on trying to understand how to use these libraries and on creating or fixing their haskell bindings.  

        <p>Secondly, OpenGL is a very annoying library to try to debug - it doesn’t give warnings, or errors, or even (usually) crash when you invoke it incorrectly. Instead, it simply fails to render what you expected.  For example the texture_from_pixmap extension, which is essential to any OpenGL-using compositor, simply failed to load any image data into my textures and gave not the slightest feedback as to what was wrong. This debilitating behavior is further exacerbated by the lack of documentation on OpenGL in haskell - aside from a pair of mini tutorials on the haskell wiki, there just isn’t anything accessible to someone not already familiar with OpenGL, and even in C tutorials, most guides assume that 1) you are writing a game, and care more about things like animation and polygons than about texturing at first, and 2) we will be using GLUT or an equivalent helper library.  Neither of these was true in my case, as I was writing a compositor, and  in order to use GLX’s texture_from_pixmap extension I had to set up the OpenGL context myself using GLX, instead of going through one of the OpenGL helper libraries, which require you to use their invocation for many of their other features to work.  I ran into this second point when trying to use GLFW to load texture data - it worked fine when I created the context within GLFW, but when I tried to use my own context it simply failed silently.  Eventually I found some sample code in haskell that would generate a checkerboard pattern and turn it into a texture, thus bypassing the libraries and letting me get a texture to test with.

        <p>Unfortunately that didn’t help me resolve my problems with texture_from_pixmap not actually loading any image data into the textures, so I implemented a software route using XGetPixel to manually copy the image data into a form my textures could use.  My first attempts failed because OpenGL apparently expects the color information to be encoded in GLubytes, while I was using haskell’s Ints.  I’m actually rather surprised the haskell type system didn’t catch that one, I guess the OpenGL bindings must not be enforcing types strongly there for some reason.  After converting everything into the format expected by OpenGL however, the software path worked, with a couple of limitations. Namely, its *horrifically* slow (about one frame in every 2-3 seconds) and it only renders actual windows, not the desktop background or xmonad-drawn window borders.

        <p>At this point, I am out of ideas on how to advance Hcompmgr.  Without a viable rendering backend, there’s not a lot I can do to keep it alive.  I have made all the code available however, in the hopes that someone might find my work to this point useful.  You can find the links to all the source repositories for this project on <a href=@{CodeR}>my code page</a>.
        

<article .blogpost
    <header
        <h3
            posts[0]
        <pubdate date="2011-04-12" pubdate
            April 12, 2011
    <div .blogentry
        <p
            Hello, and welcome to the blog.  Most blogs spend the first most introducing the author, but I already have <a href=@{AboutR}>an about page</a> that does just that, so I'll let you take a moment and read that. Done? Good.

        <p
            The purpose of this blog (and this site) is twofold. 1) To give me somewhere to post all the random things I create/discover/think about, and 2) to force me to work on my writing skills more.  Hopefully point 1 will be enough to keep point 2 going, my first couple blog attempts didn't live long. :)
